

dim tmp(1)
dim buf(255)
dim buf_idx
dim buf_ready
dim name(32)
dim name_len
dim result
dim channel
dim continue
dim escaping
dim bytes_to_send
dim tlen
dim idx
dim response_count
dim expected_length
dim send_idx
dim chunk_size

#variable to save handle
dim batconn_handle

#store battery measurement result
dim batresult

event system_boot(major,minor,patch,build,ll_version,protocol,hw)	
	batconn_handle=$ff
	buf_idx=0
	name_len=0
	buf_ready=0
	escaping=0
	response_count=0

	call flash_ps_load($8000)(result, name_len, name(0:name_len))
	if result != 0 then
	  name_len = 9
	  name(0:1) = $52 # R
	  name(1:1) = $69 # i
	  name(2:1) = $6c # l
	  name(3:1) = $65 # e
	  name(4:1) = $79 # y
	  name(5:1) = $4c # L
	  name(6:1) = $69 # i
	  name(7:1) = $6e # n
	  name(8:1) = $6b # k
	end if
	
	#start advertising in connectible mode
	call gap_set_mode(gap_general_discoverable,gap_undirected_connectable)
		
	# Make P0_0 and P0_4 outputs
	call hardware_io_port_config_direction(0, $13)
	
	# Turn P0_0 (green led) and P0_1 (blue led) off
	call hardware_io_port_write(0, $3, 0)
		

	call attributes_write(xgatt_name, 0, name_len, name(0:name_len))
	call attributes_write(xgatt_custom_name, 0, name_len, name(0:name_len))

end

event attributes_value(connection, reason, handle, offset, value_len, value_data)
	
	if handle = xgatt_custom_name then
	  memcpy(name(0), value_data(0), value_len)
	  name_len = value_len
	  call connection_disconnect(connection)
	end if
	
	if handle = xgatt_data then
	  if offset = 0 then
	    expected_length = value_data(0:1) + 1
		buf_idx = 0
		idx = 1
	  else
	    idx = 0
	  end if
	  # escape data
	  while idx < value_len
	    tmp(0:1) = value_data(idx:1)
		if tmp(0:1) = $99 || tmp(0:1) = $98
		  buf(buf_idx:1) = $98
		  buf(buf_idx+1:1) = tmp(0:1) ^ $ff
		  buf_idx = buf_idx + 2
		else
		  buf(buf_idx:1) = tmp(0:1)
		  buf_idx = buf_idx + 1
		end if
		idx = idx + 1
	  end while	  
	  
	  # Write to SPI if finished
	  if offset + value_len = expected_length then
	    bytes_to_send = buf_idx
		send_idx = 0
        call hardware_io_port_write(0, $10, 0)
		while bytes_to_send > 0
	   	  chunk_size = buf_idx - send_idx
		  if chunk_size > 32 then
		    chunk_size = 32
		  end if
          call hardware_spi_transfer(0, chunk_size, buf(send_idx:chunk_size))
		  send_idx = send_idx + chunk_size
		  bytes_to_send = bytes_to_send - chunk_size
		end while
        call hardware_io_port_write(0, $10, $10)
		
        # Prep for rx
	    buf_idx = 0
	    buf_ready = 0
	    # Start a 50ms timer to read spi
	    call hardware_set_soft_timer($666, 0, 1)
	  end if

    end if
	
	if reason = 2 then # User requesting response
	  call attributes_user_write_response(connection, 0)
	end if
end

event attributes_user_read_request(connection, handle, offset, maxsize)
	if handle = xgatt_battery then
		batconn_handle=connection
		#start measurement, read VDD/3, 9 effective bits 
		call hardware_adc_read(15,3,0)
	end if
	
	if handle = xgatt_data then

	  if buf_ready = 1 then
	    bytes_to_send = buf_idx - offset
		if (offset > buf_idx)
		  bytes_to_send = 0
		end if
		if bytes_to_send > maxsize then
		  bytes_to_send = maxsize
		end if
	    call attributes_user_read_response(connection,0,buf_idx,buf(offset:bytes_to_send))
		if offset + bytes_to_send >= buf_idx then
		  buf_idx = 0
		  buf_ready = 0
		end if
      else
	    call attributes_user_read_response(connection,0,0,buf(0:0))
	  end if
	end if
	
end

event hardware_adc_result(input,value)
    #scale value to range 0-100
	#measurement range is 32768=1.15v*3=3.45V
	#new battery ADC measurement is 32767=3.45v
	#minimum battery voltage is 2.0 volts=2.0v/3.45v*32768= 18996
	#32767-18996=13771
	
	batresult=(value-18995)*100/13772
	
	#clip to 100%
	if batresult>100 then
		batresult=100
	end if
	if batresult<0 then
	    batresult=0
	end if

	tmp(0:1)=batresult

	if batconn_handle<$ff then
		#if connection handle is valid
		call attributes_user_read_response(batconn_handle,0,1,tmp(0:1))
		batconn_handle=$ff
	end if
end

# Timer event listener to update packet count
event hardware_soft_timer(handle)
  if buf_ready = 0 then
    continue = 1
  else
    continue = 0
  end if
  call hardware_io_port_write(0, $10, 0)
  while continue 
    call hardware_spi_transfer(0,1,$99)(result,channel,tlen,tmp(0))
    if result = 0 && tmp(0:1) != $99 then
	  if tmp(0:1) = $98 then # escape code
	    escaping = 1
	  else
	    if escaping then
		  tmp(0:1) = tmp(0:1) ^ $ff
		  escaping = 0
		end if
        buf(buf_idx:1) = tmp(0:1)
	    buf_idx = buf_idx + 1
		if tmp(0:1) = $0 || buf_idx = 255 then
		  response_count = response_count + 1
		  call attributes_write(xgatt_response_count,0,1,response_count)
		  buf_ready = 1
		  continue = 0
		end if
      end if
	else
	  continue = 0
    end if
  end while
  
  call hardware_io_port_write(0, $10, $10)

  if buf_ready != 1 then
    call hardware_set_soft_timer($666, 0, 1)
  end if
  
end


# Connection event listener
event connection_status(connection, flags, address, address_type, conn_interval, timeout, latency, bonding)
	# Device is connected. Turn on green led
    call hardware_io_port_write(0, $1, $1)	
end

event connection_disconnected(handle,res)
    #start advertising again after disconnection
    call gap_set_mode(gap_general_discoverable,gap_undirected_connectable)
	# Device disconnected. Turn off green led
    call hardware_io_port_write(0, $1, $0)
	
	# Save name
	if name_len > 0
		call attributes_write(xgatt_name, 0, name_len, name(0:name_len))
		call flash_ps_save($8000, name_len, name(0:name_len))
	end if

end
